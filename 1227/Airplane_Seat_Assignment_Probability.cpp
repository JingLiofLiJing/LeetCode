class Solution {
public:
	/*  考虑一个选座位的序列(a[1], a[2], ..., a[n-1], a[n]), a[k]代表第k个选座位的乘客，不需要对应严格递增的座位号。
	 *  首先n为1的情况特殊，自己就一定能够坐回去。
	 *  当n = 2 的时候， 有两种情况：
	 *		1. 第一个人正好做到了自己的位置，其他人都能做到自己的位置上，所以一定满足条件，概率为 1/2
	 *      2. 第一个人做到了第二个位置上，则一定失败，所以概率为0
	 *  综上，结果概率为 1 / 2 
	 *  此时考虑 n  的情况，此时第一个人有n种选择，每种选择的概率为 1/n
	 *      1. 选到 a[1] 自己的座位
	 *      2. 选到 a[2] 的座位
	 *      ...
	 *      n - 1. 选到 a[n-1]的座位
	 *      n. 选到 a[n]的座位
	 *  当选到a[k]的座位时，可以知道 [2,k-1]次序的乘客一定能够做到自己的位置上，剩下的情况相当于第k个乘客在[1, k+1 ... n ]中选择，此时
	 *  如果选择了1座位，则后面一定能都正确，否则会进一步缩小选择的范围
	 *  记 F(n) 表示乘客在剩下的座位中随机选一个，但是自己的座位被占的情况下做出选择后最后一个乘客n一定能做到自己的位置上的概率，容易知道
  	 *     F(2) = 1/2
	 *     F(3) = 1/3（1 + F(2)）
	 *     F(4) = 1/4(1 + F(3) + F(2))
	 *     ...
	 *     F(n) = 1/n*(1 + F(n-1) + ... + F(2))
	 *   这样的式子在 n > 2 时， 第一个人选完之后就会触发，F(n)的情况下，当前还剩n个座位，并且当前的乘客的座位一定被别人占了，只能被迫选其他的座位。
	 *   易知道，结果都为 0.5
	 */   
	double nthPersonGetsNthSeat(int n) {
		return n == 1 ? 1.0 : 0.5;
	}
};
